
from typing import Set, Any
from explorer.models import *
from disjoint_set import DisjointSet

import json

class Net:
    def __init__(self, net_number: int, signals: Set[Signal]):
        self.net_number = net_number
        self._signals = signals
    
    def __repr__(self) -> str:
        return f"Net id={self.net_number} {self._signals}"

class SignalMap:
    """
    The boards generated by the read_.* functions only provides a list of named
    signals and how they are interconnected together. There is no such notion
    of a net.

    In reality, for the data to be useful, every signal must map to exactly one
    net. Interconnected signals must map to the same net. This allows queries
    such as 'get list of pins connected to this pin' in decent time.

    This class scans every signals in a system, and does the net mapping.
    ```
    # Given:
    # sig_a = system.board1.sig_a
    # sig_b = system.board1.sig_b
    # sig_c = system.board1.sig_c
    # sig_a.connect(sig_c)

    sm = SignalMap(system)
    sm.resolved_net(sig_a) == sm.resolved_net(sig_c) != sm.resolved_net(sig_b)
    ```
    """
    def __init__(self, system: System):
        sigmap = DisjointSet()
        self.nets: dict[Signal, Net] = dict()

        for board in system.boards:
            for signal in board.signals:
                sigmap.find(signal)
            for dummypin in board.dummypins:
                for sig in dummypin.signals:
                    sigmap.union(sig, dummypin.signals[0])
            for interface in board.interfaces:
                if interface.other is None:
                    continue
                for i in range(len(interface.pins)):
                    lhs = interface.pins[i].signal
                    rhs = interface.other.pins[i].signal
                    if lhs is None or rhs is None:
                        continue
                    sigmap.union(lhs, rhs)

        net_number = 0
        for key,sigs in sigmap.itersets(with_canonical_elements=True):
            self.nets[key] = Net(net_number, sigs)
            net_number += 1
        self.sigmap = sigmap

    def resolved_net(self, signal: Signal):
        """
        Given a signal (which is part of the system provided while constructing
        this class), get its corresponding net
        """
        if signal not in self.nets:
            signal = self.sigmap.find(signal)
        if signal not in self.nets:
            raise ValueError("Signal not part of signal map")
        return self.nets[signal]

class Serialize:
    """
    The board representation generated by the read_.* functions is inherently a
    graph.
    Serialisation do not like graphs - they prefer trees.
    Take the board representation, flatten it while keeping references to other
    nodes.

    ```
    res = json.dumps(system, default=Serialize(system))
    ```
    """
    def __init__(self, system: System) -> None:
        self.sigmap = SignalMap(system)

    def __call__(self, obj) -> Any:
        if isinstance(obj, System):
            res = dict()
            res["boards"] = dict()
            for brd in obj.boards:
                res["boards"][brd.name] = brd
            res["nets"] = []
            for net in self.sigmap.nets.values():
                res["nets"] += [net]
            return res
        if isinstance(obj, Board):
            res = dict()
            res["name"] = obj.name
            res["refdes"] = obj.refdes
            res["components"] = dict()
            for com in obj.components:
                res["components"][com.refdes] = com
            res["signals"] = dict()
            for sig in obj.signals:
                res["signals"][sig.name] = sig
            res["interfaces"] = dict()
            for iface in obj.interfaces:
                res["interfaces"][iface.name] = iface
            return res
        if isinstance(obj, Component):
            res = dict()
            res["refdes"] = obj.refdes
            res["pins"] = {}
            for pin in obj._outer_pins:
                res["pins"][pin] = obj._outer_pins[pin]
            return res
        if isinstance(obj, OuterPin):
            res = dict()
            res["name"] = obj.name
            res["signal"] = self.serialize_ref(obj.signal)
            res["interfaces"] = []
            for iface in obj.interfaces:
                res["interfaces"] += [self.serialize_ref(iface)]
            return res
        if isinstance(obj, Signal):
            res = dict()
            res["name"] = obj.name
            res["net"] = self.serialize_ref(self.sigmap.resolved_net(obj))
            res["pins"] = []
            for pin in obj._pins:
                if isinstance(pin, OuterPin) is False:
                    continue
                res["pins"] += [self.serialize_ref(pin)]
            return res
        if isinstance(obj, Net):
            res = dict()
            res["id"] = obj.net_number
            res["signals"] = []
            for signal in obj._signals:
                res["signals"] += [self.serialize_ref(signal)]
            return res
        if isinstance(obj, Interface):
            res = dict()
            res["other"] = self.serialize_ref(obj.other)
            res["pins"] = []
            for pin in obj._pins:
                res["pins"] += [self.serialize_ref(pin)]
            return res

    def serialize_ref(self, obj) -> Any:
        if isinstance(obj, Signal):
            res = dict()
            res["board"] = obj.parent.name
            res["signal"] = obj.name
            return res
        if isinstance(obj, OuterPin):
            res = dict()
            res["board"] = obj.parent.parent.name
            res["component"] = obj.parent.refdes
            res["pin"] = obj.name
            return res
        if isinstance(obj, Interface):
            res = dict()
            res["board"] = obj.parent.name
            res["interface"] = obj.name
            return res
        if isinstance(obj, Net):
            return obj.net_number

def write_json(system: System, file: str):

    with open(file, "w") as f:
        f.write(json.dumps(system, indent=4, default=Serialize(system)))
